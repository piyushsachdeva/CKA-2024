{
    "sourceFile": "Resources/Day02/GAME/src/Components/gameAI.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1744991520140,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1744991520140,
            "name": "Commit-0",
            "content": "// Minimax algorithm with alpha-beta pruning\nexport function findBestMove(board, depth, maximizingPlayer, alpha, beta) {\n  const cols = board[0].length;\n  const rows = board.length;\n  \n  // Base cases: check if game is over or max depth reached\n  const winner = checkWinner(board);\n  if (winner) {\n    return { score: winner.winner === 2 ? 100 : -100, column: null };\n  }\n  if (depth === 0) {\n    return { score: evaluatePosition(board), column: null };\n  }\n  if (isBoardFull(board)) {\n    return { score: 0, column: null };\n  }\n\n  const validMoves = getValidMoves(board);\n  if (validMoves.length === 0) {\n    return { score: 0, column: null }; // It's a tie\n  }\n  \n  if (maximizingPlayer) {\n    let bestScore = -Infinity;\n    let bestColumn = validMoves[0];\n    \n    for (const col of validMoves) {\n      const newBoard = makeMove(board, col, 2);\n      const score = findBestMove(newBoard, depth - 1, false, alpha, beta).score;\n      \n      if (score > bestScore) {\n        bestScore = score;\n        bestColumn = col;\n      }\n      alpha = Math.max(alpha, bestScore);\n      if (beta <= alpha) break;\n    }\n    \n    return { score: bestScore, column: bestColumn };\n  } else {\n    let bestScore = Infinity;\n    let bestColumn = validMoves[0];\n    \n    for (const col of validMoves) {\n      const newBoard = makeMove(board, col, 1);\n      const score = findBestMove(newBoard, depth - 1, true, alpha, beta).score;\n      \n      if (score < bestScore) {\n        bestScore = score;\n        bestColumn = col;\n      }\n      beta = Math.min(beta, bestScore);\n      if (beta <= alpha) break;\n    }\n    \n    return { score: bestScore, column: bestColumn };\n  }\n}\n\nexport function makeMove(board, col, player) {\n  const newBoard = board.map(row => [...row]);\n  for (let row = newBoard.length - 1; row >= 0; row--) {\n    if (!newBoard[row][col]) {\n      newBoard[row][col] = player;\n      break;\n    }\n  }\n  return newBoard;\n}\n\nexport function checkWinner(board) {\n  const directions = [\n    [[0, 1], [0, -1]],  // horizontal\n    [[1, 0], [-1, 0]],  // vertical\n    [[1, 1], [-1, -1]], // diagonal\n    [[1, -1], [-1, 1]]  // other diagonal\n  ];\n\n  const rows = board.length;\n  const cols = board[0].length;\n  let winningCells = [];\n\n  for (let row = 0; row < rows; row++) {\n    for (let col = 0; col < cols; col++) {\n      const player = board[row][col];\n      if (!player) continue;\n\n      for (const [dir1, dir2] of directions) {\n        const line = [[row, col]];\n        let count = 1;\n\n        // Check in first direction\n        let [r, c] = [row + dir1[0], col + dir1[1]];\n        while (r >= 0 && r < rows && c >= 0 && c < cols && board[r][c] === player) {\n          line.push([r, c]);\n          count++;\n          r += dir1[0];\n          c += dir1[1];\n        }\n\n        // Check in opposite direction\n        [r, c] = [row + dir2[0], col + dir2[1]];\n        while (r >= 0 && r < rows && c >= 0 && c < cols && board[r][c] === player) {\n          line.push([r, c]);\n          count++;\n          r += dir2[0];\n          c += dir2[1];\n        }\n\n        if (count >= 4) {\n          winningCells = line;\n          return { winner: player, winningCells };\n        }\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction getValidMoves(board) {\n  return board[0].map((_, i) => i).filter(col => !board[0][col]);\n}\n\nfunction isBoardFull(board) {\n  return !board[0].includes(0);\n}\n\nfunction evaluatePosition(board) {\n  // Simple evaluation: count potential winning positions\n  let score = 0;\n  const rows = board.length;\n  const cols = board[0].length;\n\n  // Check horizontal windows\n  for (let row = 0; row < rows; row++) {\n    for (let col = 0; col <= cols - 4; col++) {\n      const window = board[row].slice(col, col + 4);\n      score += evaluateWindow(window);\n    }\n  }\n\n  // Check vertical windows\n  for (let col = 0; col < cols; col++) {\n    for (let row = 0; row <= rows - 4; row++) {\n      const window = [\n        board[row][col],\n        board[row + 1][col],\n        board[row + 2][col],\n        board[row + 3][col]\n      ];\n      score += evaluateWindow(window);\n    }\n  }\n\n  // Check diagonal windows\n  for (let row = 0; row <= rows - 4; row++) {\n    for (let col = 0; col <= cols - 4; col++) {\n      // Diagonal down-right\n      const window1 = [\n        board[row][col],\n        board[row + 1][col + 1],\n        board[row + 2][col + 2],\n        board[row + 3][col + 3]\n      ];\n      score += evaluateWindow(window1);\n\n      // Diagonal up-right\n      if (row >= 3) {\n        const window2 = [\n          board[row][col],\n          board[row - 1][col + 1],\n          board[row - 2][col + 2],\n          board[row - 3][col + 3]\n        ];\n        score += evaluateWindow(window2);\n      }\n    }\n  }\n\n  return score;\n}\n\nfunction evaluateWindow(window) {\n  const aiCount = window.filter(cell => cell === 2).length;\n  const playerCount = window.filter(cell => cell === 1).length;\n  const emptyCount = window.filter(cell => cell === 0).length;\n\n  if (aiCount === 4) return 100;\n  if (playerCount === 4) return -100;\n  if (aiCount === 3 && emptyCount === 1) return 5;\n  if (playerCount === 3 && emptyCount === 1) return -5;\n  if (aiCount === 2 && emptyCount === 2) return 2;\n  if (playerCount === 2 && emptyCount === 2) return -2;\n  return 0;\n}\n\n// Add a default export with the main functions\nexport default {\n  findBestMove,\n  makeMove,\n  checkWinner\n};"
        }
    ]
}